EIP,Number,Category,Title,Custom name,Status,Created,Summary,Why is it important?,Abstract,Motivation,Description,Official link,GitHub link,Links,Requires,Body
ERC-1271,1271,ERC,Standard Signature Validation Method for Contracts,Smart Accounts can sign on behalf of the user,Final,2018-07-25,Standard way to verify a signature when the account is a smart contract,,"Externally Owned Accounts (EOA) can sign messages with their associated private keys, but currently contracts cannot. We propose a standard way for any contracts to verify whether a signature on a behalf of a given contract is valid. This is possible via the implementation of a `isValidSignature(hash, signature)` function on the signing contract, which can be called to validate a signature.","There are and will be many contracts that want to utilize signed messages for validation of rights-to-move assets or other purposes. In order for these contracts to be able to support non Externally Owned Accounts (i.e., contract owners), we need a standard mechanism by which a contract can indicate whether a given signature is valid or not on its behalf.One example of an application that requires signatures to be provided would be decentralized exchanges with off-chain orderbook, where buy/sell orders are signed messages. In these applications, EOAs sign orders, signaling their desire to buy/sell a given asset and giving explicit permissions to the exchange smart contracts to conclude a trade via a signature. When it comes to contracts however, regular signatures are not possible since contracts do not possess a private key, hence this proposal.",,https://eips.ethereum.org/EIPS/eip-1271,https://github.com/ethereum/ercs/blob/master/ERCS/erc-1271.md,,,
ERC-4337,4337,ERC,Account Abstraction Using Alt Mempool,,Draft,2021-09-29,"An account abstraction proposal which completely avoids consensus-layer protocol changes, instead relying on higher-layer infrastructure.",,"An account abstraction proposal which completely avoids the need for consensus-layer protocol changes. Instead of adding new protocol features and changing the bottom-layer transaction type, this proposal instead introduces a higher-layer pseudo-transaction object called a UserOperation. Users send UserOperation objects into a separate mempool. A special class of actor called bundlers package up a set of these objects into a transaction making a handleOps call to a special contract, and that transaction then gets included in a block.","See also https://ethereum-magicians.org/t/implementing-account-abstraction-as-part-of-eth1-x/4020 and the links therein for historical work and motivation, and EIP-2938 for a consensus layer proposal for implementing the same goal.This proposal takes a different approach, avoiding any adjustments to the consensus layer. It seeks to achieve the following goals:Achieve the key goal of account abstraction: allow users to use smart contract wallets containing arbitrary verification logic instead of EOAs as their primary account. Completely remove any need at all for users to also have EOAs (as status quo SC wallets and EIP-3074 both require)DecentralizationAllow any bundler (think: block builder) to participate in the process of including account-abstracted user operationsWork with all activity happening over a public mempool; users do not need to know the direct communication addresses (eg. IP, onion) of any specific actorsAvoid trust assumptions on bundlersDo not require any Ethereum consensus changes: Ethereum consensus layer development is focusing on the merge and later on scalability-oriented features, and there may not be any opportunity for further protocol changes for a long time. Hence, to increase the chance of faster adoption, this proposal avoids Ethereum consensus changes.Try to support other use casesPrivacy-preserving applicationsAtomic multi-operations (similar goal to [EIP-3074])Pay tx fees with ERC-20 tokens, allow developers to pay fees for their users, and [EIP-3074]-like sponsored transaction use cases more generallySupport aggregated signature (e.g. BLS)",,https://eips.ethereum.org/EIPS/eip-4337,https://github.com/ethereum/ercs/blob/master/ERCS/erc-4337.md,,7562,
EIP-3074,3074,Core,AUTH and AUTHCALL opcodes,,Review,2020-10-15,Allow externally owned accounts to delegate control to a contract.,,This EIP introduces two EVM instructions AUTH and AUTHCALL. The first sets a context variable authorized based on an ECDSA signature. The second sends a call as the authorized account. This essentially delegates control of the externally owned account (EOA) to a smart contract.,"Adding more functionality to EOAs has been a long-standing feature request. The requests have spanned from implementing batching capabilities, allowing for gas sponsoring, expirations, scripting, and beyond. These changes often mean increased complexity and rigidity of the protocol. In some cases, it also means increased attack surfaces.

This EIP takes a different approach. Instead of enshrining these capabilities in the protocol as transaction validity requirements, it allows users to delegate control of their EOA to a contract. This gives developers a flexible framework for developing novel transaction schemes for EOAs. A motivating use case of this EIP is that it allows any EOA to act like a smart contract wallet without deploying a contract.

Although this EIP provides great benefit to individual users, the leading motivation for this EIP is ""sponsored transactions"". This is where the fee for a transaction is provided by a different account than the one that originates the call.

With the extraordinary growth of tokens on Ethereum, it has become common for EOAs to hold valuable assets without holding any ether at all. Today, these assets must be converted to ether before they can be used to pay gas fees. However, without ether to pay for the conversion, it's impossible to convert them. Sponsored transactions break the circular dependency.",,https://eips.ethereum.org/EIPS/eip-3074,,,155,
EIP-5792,5792,Interface,Wallet Call API,,Review,2022-10-17,"Adds JSON-RPC methods for sending multiple calls from the user's wallet, and checking their status",,"Defines new JSON-RPC methods which enable apps to ask a wallet to process a batch of onchain write calls and to check on the status of those calls. Applications can specify that these onchain calls be executed taking advantage of specific capabilities previously expressed by the wallet; an additional, a novel wallet RPC is defined to enable apps to query the wallet for those capabilities.",,,https://eips.ethereum.org/EIPS/eip-5792,https://github.com/ethereum/EIPs/blob/master/EIPS/eip-5792.md,,,
EIP-7212,7212,Core,Precompile for secp256r1 Curve Support,,Review,2023-06-22,Proposal to add precompiled contract that performs signature verifications in the “secp256r1” elliptic curve.,,"This proposal creates a precompiled contract that performs signature verifications in the “secp256r1” elliptic curve by given parameters of message hash, r and s components of the signature, x and y coordinates of the public key. So that, any EVM chain - principally Ethereum rollups - will be able to integrate this precompiled contract easily.","“secp256r1” elliptic curve is a standardized curve by NIST which has the same calculations by different input parameters with “secp256k1” elliptic curve used by the “ecrecover” precompiled contract. The cost of combined attacks and the security conditions are almost the same for both curves. Adding a precompiled contract which is similar to ""ecrecover"" can provide signature verifications using the “secp256r1” elliptic curve in the smart contracts and multi-faceted benefits can occur. One important factor is that this curve is widely used and supported in many modern devices such as Apple’s Secure Enclave, Webauthn, Android Keychain which proves the user adoption. Additionally, the introduction of this precompiled contract could enable valuable features in the account abstraction which allows more efficient and flexible management of accounts by transaction signs in mobile devices. Most of the modern devices and applications rely on the “secp256r1” elliptic curve. The addition of this precompiled contract enables the verification of device native transaction signing mechanisms. For example:

Apple's Secure Enclave: There is a separate “Trusted Execution Environment” in Apple hardware which can sign arbitrary messages and can only be accessed by biometric identification.
Webauthn: Web Authentication (WebAuthn) is a web standard published by the World Wide Web Consortium (W3C). WebAuthn aims to standardize an interface for authenticating users to web-based applications and services using public-key cryptography. It is being used by almost all of the modern web browsers.
Android Keystore: Android Keystore is an API that manages the private keys and signing methods. The private keys are not processed while using Keystore as the applications’ signing method. Also, it can be done in the “Trusted Execution Environment” in the microchip.
Passkeys: Passkeys is utilizing FIDO Alliance and W3C standards. It replaces passwords with cryptographic key-pairs which is also can be used for the elliptic curve cryptography.
Modern devices have these signing mechanisms that are designed to be more secure and they are able to sign transaction data, but none of the current wallets are utilizing these signing mechanisms. So, these secure signing methods can be enabled by the proposed precompiled contract to initiate the transactions natively from the devices and also, can be used for the key management. This proposal aims to reach maximum security and convenience for the key management.",,https://eips.ethereum.org/EIPS/eip-7212,https://github.com/ethereum/EIPs/blob/master/EIPS/eip-7212.md,,,
ERC-7679,7679,ERC,UserOperation Builder,,Submitted draft,2024-04-05,Construct UserOperations without being coupled with account-specific logic.,,"Different [ERC-4337](./eip-4337.md) smart account implementations encode their signature, nonce, and calldata differently.  This makes it difficult for DApps, wallets, and smart account toolings to integrate with smart accounts without integrating with account-specific SDKs, which introduces vendor lock-in and hurts smart account adoption.

We propose a standard way for smart account implementations to put their account-specific encoding logic on-chain.","At the moment, to build a [ERC-4337](./eip-4337.md) UserOperation (UserOp for short) for a smart account requires detailed knowledge of how the smart account implementation works, since each implementation is free to encode its nonce, calldata, and signature differently.

As a simple example, one account might use an execution function called `executeFoo`, whereas another account might use an execution function called `executeBar`.  This will result in the `calldata` being different between the two accounts, even if they are executing the same call.

Therefore, someone who wants to send a UserOp for a given smart account needs to:

* Figure out which smart account implementation the account is using.
* Correctly encode signature/nonce/calldata given the smart account implementation, or use an account-specific SDK that knows how to do that.

In practice, this means that most DApps, wallets, and AA toolings today are tied to a specific smart account implementation, resulting in fragmentation and vendor lock-in.",,,https://github.com/ethereum/ERCs/pull/361,,4337,
ERC-7579,7579,ERC,Minimal Modular Smart Accounts,,Draft,2023-12-14,Modular smart account interfaces and behavior for interoperability with minimal restrictions for accounts and modules,,"This proposal outlines the minimally required interfaces and behavior for modular smart accounts and modules to ensure interoperability across implementations. For accounts, the standard specifies execution, config and fallback interfaces as well as compliance to ERC-165 and ERC-1271. For modules, the standard specifies a core interface, module types and type-specific interfaces.","Contract accounts are gaining adoption with many accounts being built using a modular architecture. These modular contract accounts (hereafter smart accounts) move functionality into external contracts (modules) in order to increase the speed and potential of innovation, to future-proof themselves and to allow customizability by developers and users. However, currently these smart accounts are built in vastly different ways, creating module fragmentation and vendor lock-in. There are several reasons for why standardizing smart accounts is very beneficial to the ecosystem, including:

Interoperability for modules to be used across different smart accounts
Interoperability for smart accounts to be used across different wallet applications and sdks
Preventing significant vendor lock-in for smart account users
However, it is highly important that this standardization is done with minimal impact on the implementation logic of the accounts, so that smart account vendors can continue to innovate, while also allowing a flourishing, multi-account-compatible module ecosystem. As a result, the goal of this standard is to define the smart account and module interfaces and behavior that is as minimal as possible while ensuring interoperability between accounts and modules.",,https://eips.ethereum.org/EIPS/eip-7579,https://github.com/ethereum/ERCs/blob/master/ERCS/erc-7579.md,,"165, 1271, 2771, 4337",
ERC-6900,6900,ERC,Modular Smart Contract Accounts and Plugins,,Draft,2023-04-18,Interfaces for composable contract accounts optionally supporting upgradability and introspection,,"This proposal standardizes smart contract accounts and account plugins, which are smart contract interfaces that allow for composable logic within smart contract accounts. This proposal is compliant with ERC-4337, and takes inspiration from ERC-2535 when defining interfaces for updating and querying modular function implementations.

This modular approach splits account functionality into three categories, implements them in external contracts, and defines an expected execution flow from accounts.","One of the goals that ERC-4337 accomplishes is abstracting the logic for execution and validation to each smart contract account.

Many new features of accounts can be built by customizing the logic that goes into the validation and execution steps. Examples of such features include session keys, subscriptions, spending limits, and role-based access control. Currently, some of these features are implemented natively by specific smart contract accounts, and others are able to be implemented by plugin systems. Examples of proprietary plugin systems include Safe modules and ZeroDev plugins.

However, managing multiple account instances provides a worse user experience, fragmenting accounts across supported features and security configurations. Additionally, it requires plugin developers to choose which platforms to support, causing either platform lock-in or duplicated development effort.

We propose a standard that coordinates the implementation work between plugin developers and wallet developers. This standard defines a modular smart contract account capable of supporting all standard-conformant plugins. This allows users to have greater portability of their data, and for plugin developers to not have to choose specific account implementations to support.

diagram showing relationship between accounts and plugins with modular functions

We take inspiration from ERC-2535's diamond pattern for routing execution based on function selectors, and create a similarly composable account. However, the standard does not require the multi-facet proxy pattern.

These plugins can contain execution logic, validation schemes, and hooks. Validation schemes define the circumstances under which the smart contract account will approve actions taken on its behalf, while hooks allow for pre- and post-execution controls.

Accounts adopting this standard will support modular, upgradable execution and validation logic. Defining this as a standard for smart contract accounts will make plugins easier to develop securely and will allow for greater interoperability.

Goals:

Provide standards for how validation, execution, and hook functions for smart contract accounts should be written.
Provide standards for how compliant accounts should add, update, remove, and inspect plugins.",,https://eips.ethereum.org/EIPS/eip-6900,https://github.com/ethereum/ERCs/blob/master/ERCS/erc-6900.md,,"165, 4337",
CAIP-25,25,CAIP,JSON-RPC Provider Authorization,,Review,2020-10-14,"CAIP-25 defines an authorization procedure for a chain agnostic provider to interface with a wallet as part of their initialization and/or ""handshake"" protocol.
",,"This proposal has the goal to define a standard procedure for decentralized applications to interface with chain agnostic cryptocurrency wallets and other user agents which govern identities (including accounts) in multiple cryptographic systems. It defines a lightweight protocol for negotiating and persisting authorizations during a session managed by a provider construct.
",The motivation comes from the lack of standardization across blockchains to expose accounts and define the expected JSON-RPC methods to be used by an application through a provider connecting to a signer or other user agent.,,,https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-25.md,,"2, 10, 171, 217",
CAIP-222,222,CAIP,Wallet Authenticate JSON-RPC Method,,Draft,2023-04-07,"This CAIP defines a JSON-RPC method to authenticate wallet ownership/control of one or more blockchain account(s), on one or more specific chains.",,This proposal provides a simpler user experience by bundling two wallet requests into a single method to provide wallet authentication when exposing blockchain accounts with a cryptographic signature,"Prior this standard Wallets were required to establish a JSON-RPC connection with an application (Dapp) to expose blockchain accounts but this required a secondary request to verify ownership of each account to return a cryptographic signature.

There are challenges regarding the flexibility of what can be signed or not without prior knowledge of the blockchain accounts but with the adoption of standards like SIWx (CAIP-122) we have the ability to define specific parameters that can be signed securely without the accounts being exposed beforehand.

This will accelerate wallet adoption by social media applications which do not require persistent sessions and only need a single cryptographic signature to verify ownership of blockchain accounts.",,,https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-222.md,,"2, 10, 74, 122",
RIP-7560,7560,Core,Native Account Abstraction,,Draft,2023-09-01,"An account abstraction proposal that introduces consensus-layer protocol changes, instead of relying on higher-layer infrastructure.",,"Combining the EIP-2938 and ERC-4337 into a comprehensive Native Account Abstraction proposal.

We propose splitting the Ethereum transaction scope into multiple steps: validations, execution, and post-transaction logic. Transaction validity is determined by the result of the validation steps of a transaction.

We further separate transaction validation for the purposes of authorization and the gas fee payment, allowing contract B to pay gas for a transaction that will be executed from account contract A.

The benefits are in backward compatibility with the emerging ERC-4337 ecosystem while achieving the long-term goal of Native Account Abstraction.","ERC-4337 can do a lot as a purely voluntary ERC. However, any of the out-of-protocol ways of achieving Account Abstraction faces several drawbacks compared to native support. There are a few key areas where it is weaker than a truly in-protocol solution:

Existing users cannot benefit from it or upgrade to use it without moving all their assets and activity to a new account.

Extra gas overhead of ~42k for a basic UserOperation compared to ~21k for a basic transaction.

Less benefit from in-protocol censorship resistance techniques such as crLists, which target transactions and would miss UserOperations.

Relying on a significantly smaller set of participating nodes and non-standard RPC methods like eth_sendRawTransactionConditional.

Inability to use tx.origin or contracts that rely on it as it returns the meaningless address of a bundler.

EIP-2938 defines a very mature alternative approach to Account Abstraction. However, it does not translate well to the architecture of ERC-4337 that is being used in production without any protocol changes. Therefore, the implementation of EIP-2938 will not benefit as much from the production experience gained by using ERC-4337 and from maintaining backward compatibility with it.

There is also a possibility that at some point in the future, the EOAs on Ethereum will be replaced with pre-deployed smart contracts. This, however, is impossible without an addition of Native Account Abstraction to the protocol.",,,https://github.com/ethereum/RIPs/blob/master/RIPS/rip-7560.md,,"4337, 6780",
EIP-6963,6963,Interface,Multi Injected Provider Discovery,,Final,2023-05-01,Using window events to announce injected Wallet Providers,,An alternative discovery mechanism to window.ethereum for EIP-1193 providers which supports discovering multiple injected Wallet Providers in a web page using Javascript's window events,"Currently, Wallet Provider that offer browser extensions must inject their Ethereum providers (EIP-1193) into the same window object window.ethereum; however, this creates conflicts for users that may install more than one browser extension.

Browser extensions are loaded in the web page in an unpredictable and unstable order, resulting in a race condition where the user does not have control over which Wallet Provider is selected to expose the Ethereum interface under the window.ethereum object. Instead, the last wallet to load usually wins.

This results not only in a degraded user experience but also increases the barrier to entry for new browser extensions as users are forced to only install one browser extension at a time.

Some browser extensions attempt to counteract this problem by delaying their injection to overwrite the same window.ethereum object which creates an unfair competition for Wallet Providers and lack of interoperability.

In this proposal, we present a solution that focuses on optimizing the interoperability of multiple Wallet Providers. This solution aims to foster fairer competition by reducing the barriers to entry for new Wallet Providers, along with enhancing the user experience on Ethereum networks.

This is achieved by introducing a set of window events to provide a two-way communication protocol between Ethereum libraries and injected scripts provided by browser extensions thus enabling users to select their wallet of choice.

Specification",,https://eips.ethereum.org/EIPS/eip-6963,https://github.com/ethereum/EIPs/blob/master/EIPS/eip-6963.md,,1193,