[
  {
    "EIP": "ERC-1271",
    "Number": "1271",
    "Category": "ERC",
    "Title": "Standard Signature Validation Method for Contracts",
    "Custom name": "Smart Accounts can sign on behalf of the user",
    "Status": "Final",
    "Created": "2018-07-25",
    "Summary": "Standard way to verify a signature when the account is a smart contract",
    "Why is it important?": "Smart Accounts (which are Smart Contracts) can now sign transactions on behalf of a user. In the past, only EOA accounts could this and a user would need to be present to sign the transaction. This will tie in nicely with the concept of session keys (sometimes called permissions), so apps can perform actions on behalf of users (assuming they’ve been granted permission by the user). ",
    "Abstract": "Externally Owned Accounts (EOA) can sign messages with their associated private keys, but currently contracts cannot. We propose a standard way for any contracts to verify whether a signature on a behalf of a given contract is valid. This is possible via the implementation of a `isValidSignature(hash, signature)` function on the signing contract, which can be called to validate a signature.",
    "Motivation": "There are and will be many contracts that want to utilize signed messages for validation of rights-to-move assets or other purposes. In order for these contracts to be able to support non Externally Owned Accounts (i.e., contract owners), we need a standard mechanism by which a contract can indicate whether a given signature is valid or not on its behalf.\n\nOne example of an application that requires signatures to be provided would be decentralized exchanges with off-chain orderbook, where buy/sell orders are signed messages. In these applications, EOAs sign orders, signaling their desire to buy/sell a given asset and giving explicit permissions to the exchange smart contracts to conclude a trade via a signature. When it comes to contracts however, regular signatures are not possible since contracts do not possess a private key, hence this proposal.",
    "Description": "",
    "Official link": "https://eips.ethereum.org/EIPS/eip-1271",
    "GitHub link": "https://github.com/ethereum/ercs/blob/master/ERCS/erc-1271.md",
    "Links": "https://eip1271.io/",
    "Requires": "",
    "Body": ""
  },
  {
    "EIP": "ERC-4337",
    "Number": "4337",
    "Category": "ERC",
    "Title": "Account Abstraction Using Alt Mempool",
    "Custom name": "",
    "Status": "Draft",
    "Created": "2021-09-29",
    "Summary": "An account abstraction proposal which completely avoids consensus-layer protocol changes, instead relying on higher-layer infrastructure.",
    "Why is it important?": "ERC-4337 moves signature verification, gas payment, and replay protection out of the core protocol and into the EVM, enabling users to use smart wallets containing arbitrary verification logic instead of EOAs as their primary account without any consensus-layer changes. This EIP introduces a UserOperations mempool which exists in parallel to the existing mempool. Bundlers (validators, MEV searchers, or the application itself) pick up transactions from the UserOperations pool, relay them to the blockchain and pay the fee. Paymasters are an optional step for transaction sponsorship. Here, the initiator wallet doesn’t pay for gas themselves, but instead applications can aggregate and sponsor gas payments for their users using fee subscription models.",
    "Abstract": "An account abstraction proposal which completely avoids the need for consensus-layer protocol changes. Instead of adding new protocol features and changing the bottom-layer transaction type, this proposal instead introduces a higher-layer pseudo-transaction object called a `UserOperation`. Users send `UserOperation` objects into a separate mempool. A special class of actor called bundlers package up a set of these objects into a transaction making a `handleOps` call to a special contract, and that transaction then gets included in a block.",
    "Motivation": "See also [https://ethereum-magicians.org/t/implementing-account-abstraction-as-part-of-eth1-x/4020](https://ethereum-magicians.org/t/implementing-account-abstraction-as-part-of-eth1-x/4020) and the links therein for historical work and motivation, and [EIP-2938](https://github.com/ethereum/ERCs/blob/master/ERCS/eip-2938.md) for a consensus layer proposal for implementing the same goal.\n\nThis proposal takes a different approach, avoiding any adjustments to the consensus layer. It seeks to achieve the following goals:\n\n* **Achieve the key goal of account abstraction**: allow users to use smart contract wallets containing arbitrary verification logic instead of EOAs as their primary account. Completely remove any need at all for users to also have EOAs (as status quo SC wallets and EIP-3074 both require)\n\n* **Decentralization**\n* Allow any bundler (think: block builder) to participate in the process of including account-abstracted user operations\n* Work with all activity happening over a public mempool; users do not need to know the direct communication addresses (eg. IP, onion) of any specific actors\n* Avoid trust assumptions on bundlers\n* **Do not require any Ethereum consensus changes**: Ethereum consensus layer development is focusing on the merge and later on scalability-oriented features, and there may not be any opportunity for further protocol changes for a long time. Hence, to increase the chance of faster adoption, this proposal avoids Ethereum consensus changes.\n* **Try to support other use cases**\n* Privacy-preserving applications\n* Atomic multi-operations (similar goal to [EIP-3074])\n* Pay tx fees with [ERC-20](https://github.com/ethereum/ERCs/blob/master/ERCS/eip-20.md) tokens, allow developers to pay fees for their users, and [EIP-3074]-like **sponsored transaction** use cases more generally\n* Support aggregated signature (e.g. BLS)",
    "Description": "",
    "Official link": "https://eips.ethereum.org/EIPS/eip-4337",
    "GitHub link": "https://github.com/ethereum/ercs/blob/master/ERCS/erc-4337.md",
    "Links": "https://www.erc4337.io/",
    "Requires": "7562",
    "Body": ""
  },
  {
    "EIP": "EIP-3074",
    "Number": "3074",
    "Category": "Core",
    "Title": "AUTH and AUTHCALL opcodes",
    "Custom name": "",
    "Status": "Review",
    "Created": "2020-10-15",
    "Summary": "Allow externally owned accounts to delegate control to a contract.",
    "Why is it important?": "This EIP introduces new opcodes that allow externally owned accounts (EOAs) to delegate their authority to smart contracts. For WalletConnect, this could significantly enhance how transactions are authorized and executed through wallets, enabling more sophisticated interaction patterns with dApps.",
    "Abstract": "This EIP introduces two EVM instructions `AUTH` and `AUTHCALL`. The first sets a context variable `authorized` based on an ECDSA signature. The second sends a call as the `authorized` account. This essentially delegates control of the externally owned account (EOA) to a smart contract.",
    "Motivation": "Adding more functionality to EOAs has been a long-standing feature request. The requests have spanned from implementing batching capabilities, allowing for gas sponsoring, expirations, scripting, and beyond. These changes often mean increased complexity and rigidity of the protocol. In some cases, it also means increased attack surfaces.\n\nThis EIP takes a different approach. Instead of enshrining these capabilities in the protocol as transaction validity requirements, it allows users to *delegate* control of their EOA to a contract. This gives developers a flexible framework for developing novel transaction schemes for EOAs. A motivating use case of this EIP is that it allows any EOA to act like a smart contract wallet *without* deploying a contract.\n\nAlthough this EIP provides great benefit to individual users, the leading motivation for this EIP is \"sponsored transactions\". This is where the fee for a transaction is provided by a different account than the one that originates the call.\n\nWith the extraordinary growth of tokens on Ethereum, it has become common for EOAs to hold valuable assets without holding any ether at all. Today, these assets must be converted to ether before they can be used to pay gas fees. However, without ether to pay for the conversion, it's impossible to convert them. Sponsored transactions break the circular dependency.",
    "Description": "",
    "Official link": "https://eips.ethereum.org/EIPS/eip-3074",
    "GitHub link": "https://github.com/ethereum/EIPs/blob/master/EIPS/eip-3074.md",
    "Links": "",
    "Requires": "155",
    "Body": ""
  },
  {
    "EIP": "EIP-5792",
    "Number": "5792",
    "Category": "Interface",
    "Title": "Wallet Call API",
    "Custom name": "",
    "Status": "Review",
    "Created": "2022-10-17",
    "Summary": "Adds JSON-RPC methods for sending multiple calls from the user's wallet, and checking their status",
    "Why is it important?": "Enables batch transactions for wallets, so that transactions can be bundled together and sponsored by apps if they wish. This ties to EIP-3074.",
    "Abstract": "Defines new JSON-RPC methods which enable apps to ask a wallet to process a batch of onchain write calls and to check on the status of those calls.\nApplications can specify that these onchain calls be executed taking advantage of specific capabilities previously expressed by the wallet; an additional, a novel wallet RPC is defined to enable apps to query the wallet for those capabilities.",
    "Motivation": "The current methods used to send transactions from the user wallet and check their status are `eth_sendTransaction` and `eth_getTransactionReceipt`.\n\nThe current methods used to send transactions from the user wallet and check their status do not meet modern developer demands and cannot accomodate new transaction formats. Even the name–- `eth_sendTransaction`-– is an artifact of a time when nodes served as wallets. \n\nToday, developers want to send multiple calls batched together in a single RPC call, which many smart accounts can, in turn, execute atomically in a single transaction. Developers also want to make use of features afforded by new transaction formats, like paymasters in [ERC-4337](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4337.md) transactions. `eth_sendTransaction` offers no way to do these things.\n\nIn updating to a new set of `wallet_` RPCs, our main goals are to enforce a clean separation of wallet and app concerns, enable developers to make use of things like paymasters and batch transactions, and to create a clear way for more safely discoverable features to be added over time with minimal coordination.",
    "Description": "",
    "Official link": "https://eips.ethereum.org/EIPS/eip-5792",
    "GitHub link": "https://github.com/ethereum/EIPs/blob/master/EIPS/eip-5792.md",
    "Links": "https://www.eip5792.xyz/",
    "Requires": "",
    "Body": ""
  },
  {
    "EIP": "EIP-7212",
    "Number": "7212",
    "Category": "Core",
    "Title": "Precompile for secp256r1 Curve Support",
    "Custom name": "",
    "Status": "Review",
    "Created": "2023-06-22",
    "Summary": "Proposal to add precompiled contract that performs signature verifications in the \u201csecp256r1\u201d elliptic curve.",
    "Why is it important?": "Proposes to add the R1 curve directly to the EVM as a precompiled contract so every modern device can natively sign transactions without third party services or middlemen.\n\nEthereum uses different cryptography than other devices that user’s utilize. This adds the type of cryptography (R1 curve) to Ethereum needed so that Ethereum can do what it needs to without using any other 3rd party services or middlemen to support the crytopgraphy needed. ",
    "Abstract": "This proposal creates a precompiled contract that performs signature verifications in the “secp256r1” elliptic curve by given parameters of message hash, `r` and `s` components of the signature, `x` and `y` coordinates of the public key. So that, any EVM chain - principally Ethereum rollups - will be able to integrate this precompiled contract easily.",
    "Motivation": "“secp256r1” elliptic curve is a standardized curve by NIST which has the same calculations by different input parameters with “secp256k1” elliptic curve used by the “ecrecover” precompiled contract. The cost of combined attacks and the security conditions are almost the same for both curves. Adding a precompiled contract which is similar to \"ecrecover\" can provide signature verifications using the “secp256r1” elliptic curve in the smart contracts and multi-faceted benefits can occur. One important factor is that this curve is widely used and supported in many modern devices such as Apple’s Secure Enclave, Webauthn, Android Keychain which proves the user adoption. Additionally, the introduction of this precompiled contract could enable valuable features in the account abstraction which allows more efficient and flexible management of accounts by transaction signs in mobile devices.\nMost of the modern devices and applications rely on the “secp256r1” elliptic curve. The addition of this precompiled contract enables the verification of device native transaction signing mechanisms. For example:\n\n1. **Apple's Secure Enclave:** There is a separate “Trusted Execution Environment” in Apple hardware which can sign arbitrary messages and can only be accessed by biometric identification.\n2. **Webauthn:** Web Authentication (WebAuthn) is a web standard published by the World Wide Web Consortium (W3C). WebAuthn aims to standardize an interface for authenticating users to web-based applications and services using public-key cryptography. It is being used by almost all of the modern web browsers.\n3. **Android Keystore:** Android Keystore is an API that manages the private keys and signing methods. The private keys are not processed while using Keystore as the applications’ signing method. Also, it can be done in the “Trusted Execution Environment” in the microchip.\n4. **Passkeys:** Passkeys is utilizing FIDO Alliance and W3C standards. It replaces passwords with cryptographic key-pairs which is also can be used for the elliptic curve cryptography.\n\nModern devices have these signing mechanisms that are designed to be more secure and they are able to sign transaction data, but none of the current wallets are utilizing these signing mechanisms. So, these secure signing methods can be enabled by the proposed precompiled contract to initiate the transactions natively from the devices and also, can be used for the key management. This proposal aims to reach maximum security and convenience for the key management.",
    "Description": "",
    "Official link": "https://eips.ethereum.org/EIPS/eip-7212",
    "GitHub link": "https://github.com/ethereum/EIPs/blob/master/EIPS/eip-7212.md",
    "Links": "",
    "Requires": "",
    "Body": ""
  },
  {
    "EIP": "ERC-7679",
    "Number": "7679",
    "Category": "ERC",
    "Title": "UserOperation Builder",
    "Custom name": "",
    "Status": "Submitted draft",
    "Created": "2024-04-05",
    "Summary": "Construct UserOperations without being coupled with account-specific logic.",
    "Why is it important?": "Allows a dApp to send UserOps even when the wallet  isn’t connected (subscriptions)",
    "Abstract": "Different [ERC-4337](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4337.md) smart account implementations encode their signature, nonce, and calldata differently.  This makes it difficult for DApps, wallets, and smart account toolings to integrate with smart accounts without integrating with account-specific SDKs, which introduces vendor lock-in and hurts smart account adoption.\n\nWe propose a standard way for smart account implementations to put their account-specific encoding logic on-chain.",
    "Motivation": "At the moment, to build a [ERC-4337](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4337.md) UserOperation (UserOp for short) for a smart account requires detailed knowledge of how the smart account implementation works, since each implementation is free to encode its nonce, calldata, and signature differently.\n\nAs a simple example, one account might use an execution function called `executeFoo`, whereas another account might use an execution function called `executeBar`.  This will result in the `calldata` being different between the two accounts, even if they are executing the same call.\n\nTherefore, someone who wants to send a UserOp for a given smart account needs to:\n\n* Figure out which smart account implementation the account is using.\n* Correctly encode signature/nonce/calldata given the smart account implementation, or use an account-specific SDK that knows how to do that.\n\nIn practice, this means that most DApps, wallets, and AA toolings today are tied to a specific smart account implementation, resulting in fragmentation and vendor lock-in.",
    "Description": "",
    "Official link": "",
    "GitHub link": "https://github.com/ethereum/ERCs/pull/361",
    "Links": "",
    "Requires": "4337",
    "Body": ""
  },
  {
    "EIP": "ERC-7579",
    "Number": "7579",
    "Category": "ERC",
    "Title": "Minimal Modular Smart Accounts",
    "Custom name": "",
    "Status": "Draft",
    "Created": "2023-12-14",
    "Summary": "Modular smart account interfaces and behavior for interoperability with minimal restrictions for accounts and modules",
    "Why is it important?": "- Improves interoperability for decentralized applications (DApps) by introducing a standardized set of interfaces for smart accounts and modules. This contrasts with ERC-6900's more rigid and complex approach.\n- Provides users with a more secure and efficient experience, leveraging the account abstraction features of ERC-4337.\n- Addresses fragmentation and uniformity issues caused by previous standards like ERC-6900.\n- Enables greater modularity in developing smart accounts.",
    "Abstract": "This proposal outlines the minimally required interfaces and behavior for modular smart accounts and modules to ensure interoperability across implementations. For accounts, the standard specifies execution, config and fallback interfaces as well as compliance to [ERC-165](https://github.com/ethereum/ERCs/blob/master/ERCS/eip-165.md) and [ERC-1271](https://github.com/ethereum/ERCs/blob/master/ERCS/eip-1271.md). For modules, the standard specifies a core interface, module types and type-specific interfaces.",
    "Motivation": "Contract accounts are gaining adoption with many accounts being built using a modular architecture. These modular contract accounts (hereafter smart accounts) move functionality into external contracts (modules) in order to increase the speed and potential of innovation, to future-proof themselves and to allow customizability by developers and users. However, currently these smart accounts are built in vastly different ways, creating module fragmentation and vendor lock-in. There are several reasons for why standardizing smart accounts is very beneficial to the ecosystem, including:\n\n- Interoperability for modules to be used across different smart accounts\n- Interoperability for smart accounts to be used across different wallet applications and sdks\n- Preventing significant vendor lock-in for smart account users\n\nHowever, it is highly important that this standardization is done with minimal impact on the implementation logic of the accounts, so that smart account vendors can continue to innovate, while also allowing a flourishing, multi-account-compatible module ecosystem. As a result, the goal of this standard is to define the smart account and module interfaces and behavior that is as minimal as possible while ensuring interoperability between accounts and modules.",
    "Description": "",
    "Official link": "https://eips.ethereum.org/EIPS/eip-7579",
    "GitHub link": "https://github.com/ethereum/ERCs/blob/master/ERCS/erc-7579.md",
    "Links": "https://erc7579.com/",
    "Requires": "165, 1271, 2771, 4337",
    "Body": ""
  },
  {
    "EIP": "ERC-6900",
    "Number": "6900",
    "Category": "ERC",
    "Title": "Modular Smart Contract Accounts and Plugins",
    "Custom name": "",
    "Status": "Draft",
    "Created": "2023-04-18",
    "Summary": "Interfaces for composable contract accounts optionally supporting upgradability and introspection",
    "Why is it important?": "Lays the groundwork for a future of permissionless innovation in modular smart accounts. By standardizing account interfaces and plugins, 6900 seeks to make it easier for developers to build secure, interoperable and composable modular smart accounts and plugins.",
    "Abstract": "This proposal standardizes smart contract accounts and account plugins, which are smart contract interfaces that allow for composable logic within smart contract accounts. This proposal is compliant with [ERC-4337](https://github.com/ethereum/ERCs/blob/master/ERCS/eip-4337.md), and takes inspiration from [ERC-2535](https://github.com/ethereum/ERCs/blob/master/ERCS/eip-2535.md) when defining interfaces for updating and querying modular function implementations.\n\nThis modular approach splits account functionality into three categories, implements them in external contracts, and defines an expected execution flow from accounts.",
    "Motivation": "One of the goals that ERC-4337 accomplishes is abstracting the logic for execution and validation to each smart contract account.\n\nMany new features of accounts can be built by customizing the logic that goes into the validation and execution steps. Examples of such features include session keys, subscriptions, spending limits, and role-based access control. Currently, some of these features are implemented natively by specific smart contract accounts, and others are able to be implemented by plugin systems. Examples of proprietary plugin systems include Safe modules and ZeroDev plugins.\n\nHowever, managing multiple account instances provides a worse user experience, fragmenting accounts across supported features and security configurations. Additionally, it requires plugin developers to choose which platforms to support, causing either platform lock-in or duplicated development effort.\n\nWe propose a standard that coordinates the implementation work between plugin developers and wallet developers. This standard defines a modular smart contract account capable of supporting all standard-conformant plugins. This allows users to have greater portability of their data, and for plugin developers to not have to choose specific account implementations to support.\n\n![diagram showing relationship between accounts and plugins with modular functions](./MSCA_Shared_Components_Diagram.svg)\n\nWe take inspiration from ERC-2535's diamond pattern for routing execution based on function selectors, and create a similarly composable account. However, the standard does not require the multi-facet proxy pattern.\n\nThese plugins can contain execution logic, validation schemes, and hooks. Validation schemes define the circumstances under which the smart contract account will approve actions taken on its behalf, while hooks allow for pre- and post-execution controls.\n\nAccounts adopting this standard will support modular, upgradable execution and validation logic. Defining this as a standard for smart contract accounts will make plugins easier to develop securely and will allow for greater interoperability.\n\nGoals:\n\n - Provide standards for how validation, execution, and hook functions for smart contract accounts should be written.\n - Provide standards for how compliant accounts should add, update, remove, and inspect plugins.",
    "Description": "",
    "Official link": "https://eips.ethereum.org/EIPS/eip-6900",
    "GitHub link": "https://github.com/ethereum/ERCs/blob/master/ERCS/erc-6900.md",
    "Links": "https://www.erc6900.io/",
    "Requires": "165, 4337",
    "Body": ""
  },
  {
    "EIP": "CAIP-25",
    "Number": "25",
    "Category": "CAIP",
    "Title": "JSON-RPC Provider Authorization",
    "Custom name": "",
    "Status": "Review",
    "Created": "2020-10-14",
    "Summary": "CAIP-25 defines an authorization procedure for a chain agnostic provider to interface with a wallet as part of their initialization and/or \"handshake\" protocol.",
    "Why is it important?": "CAIP-25 proposes a standardized way to describe and interact with blockchain assets across different blockchain networks. It mainly focuses on token identifiers which are used to uniquely identify tokens (like cryptocurrencies and digital assets) across multiple blockchains",
    "Abstract": "This proposal has the goal to define a standard procedure for decentralized applications to interface with chain agnostic cryptocurrency wallets and other user agents which govern identities (including accounts) in multiple cryptographic systems. It defines a lightweight protocol for negotiating and persisting authorizations during a session managed by a provider construct.",
    "Motivation": "The motivation comes from the lack of standardization across blockchains to expose accounts and define the expected JSON-RPC methods to be used by an application through a provider connecting to a signer or other user agent.",
    "Description": "",
    "Official link": "",
    "GitHub link": "https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-25.md",
    "Links": "",
    "Requires": "2, 10, 171, 217",
    "Body": ""
  },
  {
    "EIP": "CAIP-222",
    "Number": "222",
    "Category": "CAIP",
    "Title": "Wallet Authenticate JSON-RPC Method",
    "Custom name": "",
    "Status": "Draft",
    "Created": "2023-04-07",
    "Summary": "This CAIP defines a JSON-RPC method to authenticate wallet ownership/control of one or more blockchain account(s), on one or more specific chains.",
    "Why is it important?": "Similar to Sign in with Ethereum (SIWE), this is a chain agnostic proposal for connecting to and signing in with 1 interaction.",
    "Abstract": "This proposal provides a simpler user experience by bundling two wallet requests into a single method to provide wallet authentication when exposing blockchain accounts with a cryptographic signature",
    "Motivation": "Prior this standard Wallets were required to establish a JSON-RPC connection with an application (Dapp) to expose blockchain accounts but this required a secondary request to verify ownership of each account to return a cryptographic signature.\n\nThere are challenges regarding the flexibility of what can be signed or not without prior knowledge of the blockchain accounts but with the adoption of standards like SIWx ([CAIP-122][https://chainagnostic.org/CAIPs/caip-122]) we have the ability to define specific parameters that can be signed securely without the accounts being exposed beforehand.\n\nThis will accelerate wallet adoption by social media applications which do not require persistent sessions and only need a single cryptographic signature to verify ownership of blockchain accounts.",
    "Description": "",
    "Official link": "",
    "GitHub link": "https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-222.md",
    "Links": "",
    "Requires": "2, 10, 74, 122",
    "Body": ""
  },
  {
    "EIP": "RIP-7560",
    "Number": "7560",
    "Category": "Core",
    "Title": "Native Account Abstraction",
    "Custom name": "",
    "Status": "Draft",
    "Created": "2023-09-01",
    "Summary": "An account abstraction proposal that introduces consensus-layer protocol changes, instead of relying on higher-layer infrastructure.",
    "Why is it important?": "Native accounts on rollups",
    "Abstract": "Combining the [EIP-2938](https://eips.ethereum.org/EIPS/eip-2938) and [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337) into a comprehensive Native Account Abstraction proposal.\n\nWe propose splitting the Ethereum transaction scope into multiple steps: validations, execution, and post-transaction logic.\nTransaction validity is determined by the result of the validation steps of a transaction.\n\nWe further separate transaction validation for the purposes of authorization and the gas fee payment, allowing contract B to pay gas for a transaction that will be executed from account contract A.\n\nThe benefits are in backward compatibility with the emerging ERC-4337 ecosystem while achieving the long-term goal of Native Account Abstraction.",
    "Motivation": "ERC-4337 can do a lot as a purely voluntary ERC. However, any of the out-of-protocol ways of achieving Account Abstraction faces several drawbacks compared to native support. There are a few key areas where it is weaker than a truly in-protocol solution:\n\n* Existing users cannot benefit from it or upgrade to use it without moving all their assets and activity to a new account.\n\n* Extra gas overhead of ~42k for a basic `UserOperation` compared to ~21k for a basic transaction.\n\n* Less benefit from in-protocol censorship resistance techniques such as crLists, which target transactions and would miss `UserOperations`.\n\n* Relying on a significantly smaller set of participating nodes and non-standard RPC methods like `eth_sendRawTransactionConditional`.\n\n* Inability to use `tx.origin` or contracts that rely on it as it returns the meaningless address of a bundler.\n\nEIP-2938 defines a very mature alternative approach to Account Abstraction. However, it does not translate well to the architecture of ERC-4337 that is being used in production without any protocol changes.\nTherefore, the implementation of EIP-2938 will not benefit as much from the production experience gained by using ERC-4337 and from maintaining backward compatibility with it.\n\nThere is also a possibility that at some point in the future, the EOAs on Ethereum will be replaced with pre-deployed smart contracts. This, however, is impossible without an addition of Native Account Abstraction to the protocol.",
    "Description": "",
    "Official link": "",
    "GitHub link": "https://github.com/ethereum/RIPs/blob/master/RIPS/rip-7560.md",
    "Links": "",
    "Requires": "4337, 6780",
    "Body": ""
  },
  {
    "EIP": "EIP-6963",
    "Number": "6963",
    "Category": "Interface",
    "Title": "Multi Injected Provider Discovery",
    "Custom name": "",
    "Status": "Final",
    "Created": "2023-05-01",
    "Summary": "Using window events to announce injected Wallet Providers",
    "Why is it important?": "A web dapp can integrate with multiple wallets simultaneously by adding support for EIP-6963, which introduces an alternative discovery mechanism to the `window.ethereum` injected provider. No more hijacking the `window.ethereum` object and introducing a race condition.",
    "Abstract": "An alternative discovery mechanism to `window.ethereum` for [EIP-1193](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1193.md) providers which supports discovering multiple injected Wallet Providers in a web page using Javascript's `window` events.",
    "Motivation": "Currently, Wallet Provider that offer browser extensions must inject their Ethereum providers ([EIP-1193](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1193.md)) into the same window object `window.ethereum`; however, this creates conflicts for users that may install more than one browser extension.\n\nBrowser extensions are loaded in the web page in an unpredictable and unstable order, resulting in a race condition where the user does not have control over which Wallet Provider is selected to expose the Ethereum interface under the `window.ethereum` object. Instead, the last wallet to load usually wins.\n\nThis results not only in a degraded user experience but also increases the barrier to entry for new browser extensions as users are forced to only install one browser extension at a time.\n\nSome browser extensions attempt to counteract this problem by delaying their injection to overwrite the same `window.ethereum` object which creates an unfair competition for Wallet Providers and lack of interoperability.\n\nIn this proposal, we present a solution that focuses on optimizing the interoperability of multiple Wallet Providers. This solution aims to foster fairer competition by reducing the barriers to entry for new Wallet Providers, along with enhancing the user experience on Ethereum networks.\n\nThis is achieved by introducing a set of window events to provide a two-way communication protocol between Ethereum libraries and injected scripts provided by browser extensions thus enabling users to select their wallet of choice.",
    "Description": "",
    "Official link": "https://eips.ethereum.org/EIPS/eip-6963",
    "GitHub link": "https://github.com/ethereum/EIPs/blob/master/EIPS/eip-6963.md",
    "Links": "https://eip6963.org/",
    "Requires": "1193",
    "Body": ""
  },
  {
    "EIP": "ERC-6492",
    "Number": "6492",
    "Category": "ERC",
    "Title": "Signature Validation for Predeploy Contracts",
    "Custom name": "",
    "Status": "Final",
    "Created": "2023-02-10",
    "Summary": "A way to verify a signature when the account is a smart contract that has not been deployed yet",
    "Why is it important?": "It's impossible to validate signatures form ERC-4337 wallets until they are deployed. That means that new wallets can't sign transactions. That's a problem when we want to create a new wallet and start using it. ERC-6492 provides a way to do this. A dapp looks at a smart contract while it has not yet been deployed, simulates it and then gets its valid signature in order to sign and validate the signature of that contract.",
    "Abstract": "Contracts can sign verifiable messages via [ERC-1271](https://github.com/ethereum/ERCs/blob/master/ERCS/eip-1271.md).\n\nHowever, if the contract is not deployed yet, [ERC-1271](https://github.com/ethereum/ERCs/blob/master/ERCS/eip-1271.md) verification is impossible, as you can't call the `isValidSignature` function on said contract.\n\nWe propose a standard way for any contract or off-chain actor to verify whether a signature on behalf of a given counterfactual contract (that is not deployed yet) is valid. This standard way extends [ERC-1271](https://github.com/ethereum/ERCs/blob/master/ERCS/eip-1271.md).",
    "Motivation": "With the rising popularity of account abstraction, we often find that the best user experience for contract wallets is to defer contract deployment until the first user transaction, therefore not burdening the user with an additional deploy step before they can use their account. However, at the same time, many dApps expect signatures, not only for interactions, but also just for logging in.\n\nAs such, contract wallets have been limited in their ability to sign messages before their de-facto deployment, which is often done on the first transaction.\n\nFurthermore, not being able to sign messages from counterfactual contracts has always been a limitation of [ERC-1271](https://github.com/ethereum/ERCs/blob/master/ERCS/eip-1271.md).",
    "Description": "",
    "Official link": "https://eips.ethereum.org/EIPS/eip-6492",
    "GitHub link": "https://github.com/ethereum/ercs/blob/master/ERCS/erc-6492.md",
    "Links": "",
    "Requires": "1271",
    "Body": ""
  },
  {
    "EIP": "ERC-7677",
    "Number": "7677",
    "Category": "ERC",
    "Title": "Paymaster Web Service Capability",
    "Custom name": "",
    "Status": "Draft",
    "Created": "2024-04-03",
    "Summary": "A way for apps to communicate with smart wallets about paymaster web services",
    "Why is it important?": "ERC-7677 proposes an EIP-5792-compliant capability for paymaster web service communication by proposing a standardized communication protocol for wallets and ERC-4337 paymaster web services.\n\nThis ultimately unlocks the ability for app developers to sponsor their users' transactions.",
    "Abstract": "With [EIP-5792](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-5792.md), apps can communicate with wallets about advanced features via capabilities. This proposal defines a capability that allows apps to request that [ERC-4337](https://github.com/ethereum/ercs/blob/master/ERCS/erc-4337.md) wallets communicate with a specified paymaster web service. To support this, we also define a standardized API for paymaster web services.",
    "Motivation": "App developers want to start sponsoring their users' transactions using paymasters. Paymasters are commonly used via web services. However, there is currently no way for apps to tell wallets to communicate with a specific paymaster web service. Similarly, there is no standard for how wallets should communicate with these services. We need both a way for apps to tell wallets to communicate with a specific paymaster web service and a communication standard for wallets to do so.",
    "Description": "",
    "Official link": "",
    "GitHub link": "https://github.com/ethereum/ERCs/pull/360/files",
    "Links": "https://www.erc7677.xyz/",
    "Requires": "4337, 5792",
    "Body": ""
  },
  {
    "EIP": "EIP-5806",
    "Number": "5806",
    "Category": "Core",
    "Title": "Delegate transaction",
    "Custom name": "",
    "Status": "Draft",
    "Created": "2022-10-20",
    "Summary": "Adds a new transaction type that allows a EOAs to execute arbitrary code through delegation",
    "Why is it important?": "Introduces a new transaction type that allows Externally Owned Accounts (EOAs) to execute arbitrary code using a delegate-call-like mechanism. This is significant because it extends the capabilities of EOAs, which are traditionally limited to deploying contracts and sending \"call\" transactions, by enabling them to perform more complex operations similar to those of smart contracts.\n\nEIP-5806 is noteworthy for its potential to significantly enhance the functionality and security of EOAs, paving the way for more complex and secure interactions on the Ethereum network.",
    "Abstract": "This EIP adds a new transaction type that allows EOAs to execute arbitrary code using a delegate-call-like mechanism.",
    "Motivation": "EOA are the most widely used type of account, yet their ability to perform operations is limited to deploying contracts and sending \"call\" transactions. It is currently not possible for an EOA to execute arbitrary code, which greatly limits the interactions users can have with the blockchain. Account abstraction has been extensively discussed but the path toward mainstream adoption is still unclear. Some approaches, such as [ERC-4337](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4337.md) hope to improve the usability of smart wallets, without addressing the issue of smart wallet support by applications.\n\nWhile smart contract wallets have a lot to offer in terms of UX, it is unlikely that all users will migrate any time soon because of the associated cost and the fact that some EOAs have custody of non-transferable assets.\n\nThis EIP proposes an approach to allow the execution of arbitrary code by EOAs, with minimal change over the EVM, and using the same security model users are used to. By allowing EOAs to perform delegate calls to a contract (similarly to how contracts can delegate calls to other contracts using [EIP-7](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-7.md)), EOAs will be able to have more control over what operations they want to execute. This proposal's goal is NOT to provide an account abstraction primitive.\n\nBy performing a delegate call to a multicall contract (such as the one deployed to `0xcA11bde05977b3631167028862bE2a173976CA11`), EOAs would be able to batch multiple transactions into a single one (being the `msg.sender` of all the sub calls). This would provide a better UX for users that want to interact with protocols (no need for multiple transactions, with variable gas prices and 21k gas overhead) and increase the security of such interactions (by avoiding unsafe token approvals being exploited between an `approval` and the following `transferFrom`).\n\nOther unforeseen logic could be implemented in smart contracts and used by EOA. This includes emitting events.\n\nThis EIP doesn't aim to replace other account abstraction proposals. It hopes to be an easy-to-implement alternative that would significantly improve the user experience of EOA owners in the near future.",
    "Description": "",
    "Official link": "https://eips.ethereum.org/EIPS/eip-5806",
    "GitHub link": "https://github.com/ethereum/EIPs/blob/master/EIPS/eip-5806.md",
    "Links": "https://www.erc7677.xyz/",
    "Requires": "2718, 2930",
    "Body": ""
  }
]
